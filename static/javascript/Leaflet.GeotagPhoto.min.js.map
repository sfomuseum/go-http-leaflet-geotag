{"version":3,"file":null,"sources":["../node_modules/@turf/invariant/index.js","../node_modules/@turf/helpers/index.js","../node_modules/@turf/meta/index.js","../node_modules/@turf/bearing/index.js","../node_modules/field-of-view/index.js","../src/Leaflet.GeotagPhoto.Crosshair.js","../node_modules/@turf/destination/index.js","../node_modules/@turf/centroid/index.js","../node_modules/@turf/distance/index.js","../src/Leaflet.GeotagPhoto.CameraControl.js","../src/Leaflet.GeotagPhoto.Camera.js","../index.js"],"sourcesContent":["/**\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\n *\n * @param {Array<any>|Geometry|Feature<Point>} obj any value\n * @returns {Array<number>} coordinates\n */\nfunction getCoord(obj) {\n    if (!obj) throw new Error('No obj passed');\n\n    var coordinates = getCoords(obj);\n\n    // getCoord() must contain at least two numbers (Point)\n    if (coordinates.length > 1 &&\n        typeof coordinates[0] === 'number' &&\n        typeof coordinates[1] === 'number') {\n        return coordinates;\n    } else {\n        throw new Error('Coordinate is not a valid Point');\n    }\n}\n\n/**\n * Unwrap coordinates from a Feature, Geometry Object or an Array of numbers\n *\n * @param {Array<any>|Geometry|Feature<any>} obj any value\n * @returns {Array<any>} coordinates\n */\nfunction getCoords(obj) {\n    if (!obj) throw new Error('No obj passed');\n    var coordinates;\n\n    // Array of numbers\n    if (obj.length) {\n        coordinates = obj;\n\n    // Geometry Object\n    } else if (obj.coordinates) {\n        coordinates = obj.coordinates;\n\n    // Feature\n    } else if (obj.geometry && obj.geometry.coordinates) {\n        coordinates = obj.geometry.coordinates;\n    }\n    // Checks if coordinates contains a number\n    if (coordinates) {\n        containsNumber(coordinates);\n        return coordinates;\n    }\n    throw new Error('No valid coordinates');\n}\n\n/**\n * Checks if coordinates contains a number\n *\n * @private\n * @param {Array<any>} coordinates GeoJSON Coordinates\n * @returns {boolean} true if Array contains a number\n */\nfunction containsNumber(coordinates) {\n    if (coordinates.length > 1 &&\n        typeof coordinates[0] === 'number' &&\n        typeof coordinates[1] === 'number') {\n        return true;\n    }\n    if (coordinates[0].length) {\n        return containsNumber(coordinates[0]);\n    }\n    throw new Error('coordinates must only contain numbers');\n}\n\n/**\n * Enforce expectations about types of GeoJSON objects for Turf.\n *\n * @alias geojsonType\n * @param {GeoJSON} value any GeoJSON object\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nfunction geojsonType(value, type, name) {\n    if (!type || !name) throw new Error('type and name required');\n\n    if (!value || value.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + value.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link Feature} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @alias featureOf\n * @param {Feature} feature a feature with an expected geometry type\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} error if value is not the expected type.\n */\nfunction featureOf(feature, type, name) {\n    if (!feature) throw new Error('No feature passed');\n    if (!name) throw new Error('.featureOf() requires a name');\n    if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n        throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @alias collectionOf\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nfunction collectionOf(featureCollection, type, name) {\n    if (!featureCollection) throw new Error('No featureCollection passed');\n    if (!name) throw new Error('.collectionOf() requires a name');\n    if (!featureCollection || featureCollection.type !== 'FeatureCollection') {\n        throw new Error('Invalid input to ' + name + ', FeatureCollection required');\n    }\n    for (var i = 0; i < featureCollection.features.length; i++) {\n        var feature = featureCollection.features[i];\n        if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n            throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n        }\n        if (!feature.geometry || feature.geometry.type !== type) {\n            throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n        }\n    }\n}\n\nmodule.exports.geojsonType = geojsonType;\nmodule.exports.collectionOf = collectionOf;\nmodule.exports.featureOf = featureOf;\nmodule.exports.getCoord = getCoord;\nmodule.exports.getCoords = getCoords;\n","/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} properties properties\n * @returns {FeatureCollection} a FeatureCollection of input features\n * @example\n * var geometry = {\n *      \"type\": \"Point\",\n *      \"coordinates\": [\n *        67.5,\n *        32.84267363195431\n *      ]\n *    }\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nfunction feature(geometry, properties) {\n    if (!geometry) throw new Error('No geometry passed');\n\n    return {\n        type: 'Feature',\n        properties: properties || {},\n        geometry: geometry\n    };\n}\nmodule.exports.feature = feature;\n\n/**\n * Takes coordinates and properties (optional) and returns a new {@link Point} feature.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object=} properties an Object that is used as the {@link Feature}'s\n * properties\n * @returns {Feature<Point>} a Point feature\n * @example\n * var pt1 = turf.point([-75.343, 39.984]);\n *\n * //=pt1\n */\nmodule.exports.point = function (coordinates, properties) {\n    if (!coordinates) throw new Error('No coordinates passed');\n    if (coordinates.length === undefined) throw new Error('Coordinates must be an array');\n    if (coordinates.length < 2) throw new Error('Coordinates must be at least 2 numbers long');\n    if (typeof coordinates[0] !== 'number' || typeof coordinates[1] !== 'number') throw new Error('Coordinates must numbers');\n\n    return feature({\n        type: 'Point',\n        coordinates: coordinates\n    }, properties);\n};\n\n/**\n * Takes an array of LinearRings and optionally an {@link Object} with properties and returns a {@link Polygon} feature.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object=} properties a properties object\n * @returns {Feature<Polygon>} a Polygon feature\n * @throws {Error} throw an error if a LinearRing of the polygon has too few positions\n * or if a LinearRing of the Polygon does not have matching Positions at the\n * beginning & end.\n * @example\n * var polygon = turf.polygon([[\n *  [-2.275543, 53.464547],\n *  [-2.275543, 53.489271],\n *  [-2.215118, 53.489271],\n *  [-2.215118, 53.464547],\n *  [-2.275543, 53.464547]\n * ]], { name: 'poly1', population: 400});\n *\n * //=polygon\n */\nmodule.exports.polygon = function (coordinates, properties) {\n    if (!coordinates) throw new Error('No coordinates passed');\n\n    for (var i = 0; i < coordinates.length; i++) {\n        var ring = coordinates[i];\n        if (ring.length < 4) {\n            throw new Error('Each LinearRing of a Polygon must have 4 or more Positions.');\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error('First and last Position are not equivalent.');\n            }\n        }\n    }\n\n    return feature({\n        type: 'Polygon',\n        coordinates: coordinates\n    }, properties);\n};\n\n/**\n * Creates a {@link LineString} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object=} properties an Object of key-value pairs to add as properties\n * @returns {Feature<LineString>} a LineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var linestring1 = turf.lineString([\n *   [-21.964416, 64.148203],\n *   [-21.956176, 64.141316],\n *   [-21.93901, 64.135924],\n *   [-21.927337, 64.136673]\n * ]);\n * var linestring2 = turf.lineString([\n *   [-21.929054, 64.127985],\n *   [-21.912918, 64.134726],\n *   [-21.916007, 64.141016],\n *   [-21.930084, 64.14446]\n * ], {name: 'line 1', distance: 145});\n *\n * //=linestring1\n *\n * //=linestring2\n */\nmodule.exports.lineString = function (coordinates, properties) {\n    if (!coordinates) throw new Error('No coordinates passed');\n\n    return feature({\n        type: 'LineString',\n        coordinates: coordinates\n    }, properties);\n};\n\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @returns {FeatureCollection} a FeatureCollection of input features\n * @example\n * var features = [\n *  turf.point([-75.343, 39.984], {name: 'Location A'}),\n *  turf.point([-75.833, 39.284], {name: 'Location B'}),\n *  turf.point([-75.534, 39.123], {name: 'Location C'})\n * ];\n *\n * var fc = turf.featureCollection(features);\n *\n * //=fc\n */\nmodule.exports.featureCollection = function (features) {\n    if (!features) throw new Error('No features passed');\n\n    return {\n        type: 'FeatureCollection',\n        features: features\n    };\n};\n\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object=} properties an Object of key-value pairs to add as properties\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n *\n */\nmodule.exports.multiLineString = function (coordinates, properties) {\n    if (!coordinates) throw new Error('No coordinates passed');\n\n    return feature({\n        type: 'MultiLineString',\n        coordinates: coordinates\n    }, properties);\n};\n\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object=} properties an Object of key-value pairs to add as properties\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n *\n */\nmodule.exports.multiPoint = function (coordinates, properties) {\n    if (!coordinates) throw new Error('No coordinates passed');\n\n    return feature({\n        type: 'MultiPoint',\n        coordinates: coordinates\n    }, properties);\n};\n\n\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object=} properties an Object of key-value pairs to add as properties\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nmodule.exports.multiPolygon = function (coordinates, properties) {\n    if (!coordinates) throw new Error('No coordinates passed');\n\n    return feature({\n        type: 'MultiPolygon',\n        coordinates: coordinates\n    }, properties);\n};\n\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<{Geometry}>} geometries an array of GeoJSON Geometries\n * @param {Object=} properties an Object of key-value pairs to add as properties\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = {\n *     \"type\": \"Point\",\n *       \"coordinates\": [100, 0]\n *     };\n * var line = {\n *     \"type\": \"LineString\",\n *     \"coordinates\": [ [101, 0], [102, 1] ]\n *   };\n * var collection = turf.geometryCollection([pt, line]);\n *\n * //=collection\n */\nmodule.exports.geometryCollection = function (geometries, properties) {\n    if (!geometries) throw new Error('No geometries passed');\n\n    return feature({\n        type: 'GeometryCollection',\n        geometries: geometries\n    }, properties);\n};\n\nvar factors = {\n    miles: 3960,\n    nauticalmiles: 3441.145,\n    degrees: 57.2957795,\n    radians: 1,\n    inches: 250905600,\n    yards: 6969600,\n    meters: 6373000,\n    metres: 6373000,\n    kilometers: 6373,\n    kilometres: 6373,\n    feet: 20908792.65\n};\n\n/*\n * Convert a distance measurement from radians to a more friendly unit.\n *\n * @name radiansToDistance\n * @param {number} distance in radians across the sphere\n * @param {string} [units=kilometers] can be degrees, radians, miles, or kilometers\n * inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} distance\n */\nmodule.exports.radiansToDistance = function (radians, units) {\n    var factor = factors[units || 'kilometers'];\n    if (factor === undefined) throw new Error('Invalid unit');\n\n    return radians * factor;\n};\n\n/*\n * Convert a distance measurement from a real-world unit into radians\n *\n * @name distanceToRadians\n * @param {number} distance in real units\n * @param {string} [units=kilometers] can be degrees, radians, miles, or kilometers\n * inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} radians\n */\nmodule.exports.distanceToRadians = function (distance, units) {\n    var factor = factors[units || 'kilometers'];\n    if (factor === undefined) throw new Error('Invalid unit');\n\n    return distance / factor;\n};\n\n/*\n * Convert a distance measurement from a real-world unit into degrees\n *\n * @name distanceToRadians\n * @param {number} distance in real units\n * @param {string} [units=kilometers] can be degrees, radians, miles, or kilometers\n * inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nmodule.exports.distanceToDegrees = function (distance, units) {\n    var factor = factors[units || 'kilometers'];\n    if (factor === undefined) throw new Error('Invalid unit');\n\n    return (distance / factor) * 57.2958;\n};\n","/**\n * Callback for coordEach\n *\n * @private\n * @callback coordEachCallback\n * @param {[number, number]} currentCoords The current coordinates being processed.\n * @param {number} currentIndex The index of the current element being processed in the\n * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {Object} layer any GeoJSON object\n * @param {Function} callback a method that takes (currentCoords, currentIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include\n * the final coordinate of LinearRings that wraps the ring in its iteration.\n * @example\n * var features = {\n *   \"type\": \"FeatureCollection\",\n *   \"features\": [\n *     {\n *       \"type\": \"Feature\",\n *       \"properties\": {},\n *       \"geometry\": {\n *         \"type\": \"Point\",\n *         \"coordinates\": [26, 37]\n *       }\n *     },\n *     {\n *       \"type\": \"Feature\",\n *       \"properties\": {},\n *       \"geometry\": {\n *         \"type\": \"Point\",\n *         \"coordinates\": [36, 53]\n *       }\n *     }\n *   ]\n * };\n * turf.coordEach(features, function (currentCoords, currentIndex) {\n *   //=currentCoords\n *   //=currentIndex\n * });\n */\nfunction coordEach(layer, callback, excludeWrapCoord) {\n    var i, j, k, g, l, geometry, stopG, coords,\n        geometryMaybeCollection,\n        wrapShrink = 0,\n        currentIndex = 0,\n        isGeometryCollection,\n        isFeatureCollection = layer.type === 'FeatureCollection',\n        isFeature = layer.type === 'Feature',\n        stop = isFeatureCollection ? layer.features.length : 1;\n\n  // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n    for (i = 0; i < stop; i++) {\n\n        geometryMaybeCollection = (isFeatureCollection ? layer.features[i].geometry :\n        (isFeature ? layer.geometry : layer));\n        isGeometryCollection = geometryMaybeCollection.type === 'GeometryCollection';\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (g = 0; g < stopG; g++) {\n            geometry = isGeometryCollection ?\n            geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n            coords = geometry.coordinates;\n\n            wrapShrink = (excludeWrapCoord &&\n                (geometry.type === 'Polygon' || geometry.type === 'MultiPolygon')) ?\n                1 : 0;\n\n            if (geometry.type === 'Point') {\n                callback(coords, currentIndex);\n                currentIndex++;\n            } else if (geometry.type === 'LineString' || geometry.type === 'MultiPoint') {\n                for (j = 0; j < coords.length; j++) {\n                    callback(coords[j], currentIndex);\n                    currentIndex++;\n                }\n            } else if (geometry.type === 'Polygon' || geometry.type === 'MultiLineString') {\n                for (j = 0; j < coords.length; j++)\n                    for (k = 0; k < coords[j].length - wrapShrink; k++) {\n                        callback(coords[j][k], currentIndex);\n                        currentIndex++;\n                    }\n            } else if (geometry.type === 'MultiPolygon') {\n                for (j = 0; j < coords.length; j++)\n                    for (k = 0; k < coords[j].length; k++)\n                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                            callback(coords[j][k][l], currentIndex);\n                            currentIndex++;\n                        }\n            } else if (geometry.type === 'GeometryCollection') {\n                for (j = 0; j < geometry.geometries.length; j++)\n                    coordEach(geometry.geometries[j], callback, excludeWrapCoord);\n            } else {\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n    }\n}\nmodule.exports.coordEach = coordEach;\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @private\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {[number, number]} currentCoords The current coordinate being processed.\n * @param {number} currentIndex The index of the current element being processed in the\n * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {Object} layer any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoords, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include\n * the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = {\n *   \"type\": \"FeatureCollection\",\n *   \"features\": [\n *     {\n *       \"type\": \"Feature\",\n *       \"properties\": {},\n *       \"geometry\": {\n *         \"type\": \"Point\",\n *         \"coordinates\": [26, 37]\n *       }\n *     },\n *     {\n *       \"type\": \"Feature\",\n *       \"properties\": {},\n *       \"geometry\": {\n *         \"type\": \"Point\",\n *         \"coordinates\": [36, 53]\n *       }\n *     }\n *   ]\n * };\n * turf.coordReduce(features, function (previousValue, currentCoords, currentIndex) {\n *   //=previousValue\n *   //=currentCoords\n *   //=currentIndex\n *   return currentCoords;\n * });\n */\nfunction coordReduce(layer, callback, initialValue, excludeWrapCoord) {\n    var previousValue = initialValue;\n    coordEach(layer, function (currentCoords, currentIndex) {\n        if (currentIndex === 0 && initialValue === undefined) {\n            previousValue = currentCoords;\n        } else {\n            previousValue = callback(previousValue, currentCoords, currentIndex);\n        }\n    }, excludeWrapCoord);\n    return previousValue;\n}\nmodule.exports.coordReduce = coordReduce;\n\n/**\n * Callback for propEach\n *\n * @private\n * @callback propEachCallback\n * @param {*} currentProperties The current properties being processed.\n * @param {number} currentIndex The index of the current element being processed in the\n * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {Object} layer any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, currentIndex)\n * @example\n * var features = {\n *   \"type\": \"FeatureCollection\",\n *   \"features\": [\n *     {\n *       \"type\": \"Feature\",\n *       \"properties\": {\"foo\": \"bar\"},\n *       \"geometry\": {\n *         \"type\": \"Point\",\n *         \"coordinates\": [26, 37]\n *       }\n *     },\n *     {\n *       \"type\": \"Feature\",\n *       \"properties\": {\"hello\": \"world\"},\n *       \"geometry\": {\n *         \"type\": \"Point\",\n *         \"coordinates\": [36, 53]\n *       }\n *     }\n *   ]\n * };\n * turf.propEach(features, function (currentProperties, currentIndex) {\n *   //=currentProperties\n *   //=currentIndex\n * });\n */\nfunction propEach(layer, callback) {\n    var i;\n    switch (layer.type) {\n    case 'FeatureCollection':\n        for (i = 0; i < layer.features.length; i++) {\n            callback(layer.features[i].properties, i);\n        }\n        break;\n    case 'Feature':\n        callback(layer.properties, 0);\n        break;\n    }\n}\nmodule.exports.propEach = propEach;\n\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @private\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current properties being processed.\n * @param {number} currentIndex The index of the current element being processed in the\n * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {Object} layer any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = {\n *   \"type\": \"FeatureCollection\",\n *   \"features\": [\n *     {\n *       \"type\": \"Feature\",\n *       \"properties\": {\"foo\": \"bar\"},\n *       \"geometry\": {\n *         \"type\": \"Point\",\n *         \"coordinates\": [26, 37]\n *       }\n *     },\n *     {\n *       \"type\": \"Feature\",\n *       \"properties\": {\"hello\": \"world\"},\n *       \"geometry\": {\n *         \"type\": \"Point\",\n *         \"coordinates\": [36, 53]\n *       }\n *     }\n *   ]\n * };\n * turf.propReduce(features, function (previousValue, currentProperties, currentIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=currentIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(layer, callback, initialValue) {\n    var previousValue = initialValue;\n    propEach(layer, function (currentProperties, currentIndex) {\n        if (currentIndex === 0 && initialValue === undefined) {\n            previousValue = currentProperties;\n        } else {\n            previousValue = callback(previousValue, currentProperties, currentIndex);\n        }\n    });\n    return previousValue;\n}\nmodule.exports.propReduce = propReduce;\n\n/**\n * Callback for featureEach\n *\n * @private\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current feature being processed.\n * @param {number} currentIndex The index of the current element being processed in the\n * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {Object} layer any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, currentIndex)\n * @example\n * var features = {\n *   \"type\": \"FeatureCollection\",\n *   \"features\": [\n *     {\n *       \"type\": \"Feature\",\n *       \"properties\": {},\n *       \"geometry\": {\n *         \"type\": \"Point\",\n *         \"coordinates\": [26, 37]\n *       }\n *     },\n *     {\n *       \"type\": \"Feature\",\n *       \"properties\": {},\n *       \"geometry\": {\n *         \"type\": \"Point\",\n *         \"coordinates\": [36, 53]\n *       }\n *     }\n *   ]\n * };\n * turf.featureEach(features, function (currentFeature, currentIndex) {\n *   //=currentFeature\n *   //=currentIndex\n * });\n */\nfunction featureEach(layer, callback) {\n    if (layer.type === 'Feature') {\n        callback(layer, 0);\n    } else if (layer.type === 'FeatureCollection') {\n        for (var i = 0; i < layer.features.length; i++) {\n            callback(layer.features[i], i);\n        }\n    }\n}\nmodule.exports.featureEach = featureEach;\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @private\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} currentIndex The index of the current element being processed in the\n * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {Object} layer any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = {\n *   \"type\": \"FeatureCollection\",\n *   \"features\": [\n *     {\n *       \"type\": \"Feature\",\n *       \"properties\": {\"foo\": \"bar\"},\n *       \"geometry\": {\n *         \"type\": \"Point\",\n *         \"coordinates\": [26, 37]\n *       }\n *     },\n *     {\n *       \"type\": \"Feature\",\n *       \"properties\": {\"hello\": \"world\"},\n *       \"geometry\": {\n *         \"type\": \"Point\",\n *         \"coordinates\": [36, 53]\n *       }\n *     }\n *   ]\n * };\n * turf.featureReduce(features, function (previousValue, currentFeature, currentIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=currentIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(layer, callback, initialValue) {\n    var previousValue = initialValue;\n    featureEach(layer, function (currentFeature, currentIndex) {\n        if (currentIndex === 0 && initialValue === undefined) {\n            previousValue = currentFeature;\n        } else {\n            previousValue = callback(previousValue, currentFeature, currentIndex);\n        }\n    });\n    return previousValue;\n}\nmodule.exports.featureReduce = featureReduce;\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {Object} layer any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = {\n *   \"type\": \"FeatureCollection\",\n *   \"features\": [\n *     {\n *       \"type\": \"Feature\",\n *       \"properties\": {},\n *       \"geometry\": {\n *         \"type\": \"Point\",\n *         \"coordinates\": [26, 37]\n *       }\n *     },\n *     {\n *       \"type\": \"Feature\",\n *       \"properties\": {},\n *       \"geometry\": {\n *         \"type\": \"Point\",\n *         \"coordinates\": [36, 53]\n *       }\n *     }\n *   ]\n * };\n * var coords = turf.coordAll(features);\n * //=coords\n */\nfunction coordAll(layer) {\n    var coords = [];\n    coordEach(layer, function (coord) {\n        coords.push(coord);\n    });\n    return coords;\n}\nmodule.exports.coordAll = coordAll;\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {Object} layer any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, currentIndex)\n * @example\n * var features = {\n *   \"type\": \"FeatureCollection\",\n *   \"features\": [\n *     {\n *       \"type\": \"Feature\",\n *       \"properties\": {},\n *       \"geometry\": {\n *         \"type\": \"Point\",\n *         \"coordinates\": [26, 37]\n *       }\n *     },\n *     {\n *       \"type\": \"Feature\",\n *       \"properties\": {},\n *       \"geometry\": {\n *         \"type\": \"Point\",\n *         \"coordinates\": [36, 53]\n *       }\n *     }\n *   ]\n * };\n * turf.geomEach(features, function (currentGeometry, currentIndex) {\n *   //=currentGeometry\n *   //=currentIndex\n * });\n */\nfunction geomEach(layer, callback) {\n    var i, j, g, geometry, stopG,\n        geometryMaybeCollection,\n        isGeometryCollection,\n        currentIndex = 0,\n        isFeatureCollection = layer.type === 'FeatureCollection',\n        isFeature = layer.type === 'Feature',\n        stop = isFeatureCollection ? layer.features.length : 1;\n\n  // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n    for (i = 0; i < stop; i++) {\n\n        geometryMaybeCollection = (isFeatureCollection ? layer.features[i].geometry :\n        (isFeature ? layer.geometry : layer));\n        isGeometryCollection = geometryMaybeCollection.type === 'GeometryCollection';\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (g = 0; g < stopG; g++) {\n            geometry = isGeometryCollection ?\n            geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n\n            if (geometry.type === 'Point' ||\n                geometry.type === 'LineString' ||\n                geometry.type === 'MultiPoint' ||\n                geometry.type === 'Polygon' ||\n                geometry.type === 'MultiLineString' ||\n                geometry.type === 'MultiPolygon') {\n                callback(geometry, currentIndex);\n                currentIndex++;\n            } else if (geometry.type === 'GeometryCollection') {\n                for (j = 0; j < geometry.geometries.length; j++) {\n                    callback(geometry.geometries[j], currentIndex);\n                    currentIndex++;\n                }\n            } else {\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n    }\n}\nmodule.exports.geomEach = geomEach;\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @private\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentGeometry The current Feature being processed.\n * @param {number} currentIndex The index of the current element being processed in the\n * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {Object} layer any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = {\n *   \"type\": \"FeatureCollection\",\n *   \"features\": [\n *     {\n *       \"type\": \"Feature\",\n *       \"properties\": {\"foo\": \"bar\"},\n *       \"geometry\": {\n *         \"type\": \"Point\",\n *         \"coordinates\": [26, 37]\n *       }\n *     },\n *     {\n *       \"type\": \"Feature\",\n *       \"properties\": {\"hello\": \"world\"},\n *       \"geometry\": {\n *         \"type\": \"Point\",\n *         \"coordinates\": [36, 53]\n *       }\n *     }\n *   ]\n * };\n * turf.geomReduce(features, function (previousValue, currentGeometry, currentIndex) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=currentIndex\n *   return currentGeometry\n * });\n */\nfunction geomReduce(layer, callback, initialValue) {\n    var previousValue = initialValue;\n    geomEach(layer, function (currentGeometry, currentIndex) {\n        if (currentIndex === 0 && initialValue === undefined) {\n            previousValue = currentGeometry;\n        } else {\n            previousValue = callback(previousValue, currentGeometry, currentIndex);\n        }\n    });\n    return previousValue;\n}\nmodule.exports.geomReduce = geomReduce;\n","var getCoord = require('@turf/invariant').getCoord;\n//http://en.wikipedia.org/wiki/Haversine_formula\n//http://www.movable-type.co.uk/scripts/latlong.html\n\n/**\n * Takes two {@link Point|points} and finds the geographic bearing between them.\n *\n * @name bearing\n * @param {Feature<Point>} start starting Point\n * @param {Feature<Point>} end ending Point\n * @param {boolean} [final=false] calculates the final bearing if true\n * @returns {number} bearing in decimal degrees\n * @addToMap point1, point2\n * @example\n * var point1 = {\n *   \"type\": \"Feature\",\n *   \"properties\": {\n *     \"marker-color\": '#f00'\n *   },\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [-75.343, 39.984]\n *   }\n * };\n * var point2 = {\n *   \"type\": \"Feature\",\n *   \"properties\": {\n *     \"marker-color\": '#0f0'\n *   },\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [-75.534, 39.123]\n *   }\n * };\n *\n * var bearing = turf.bearing(point1, point2);\n * point1.properties.bearing = bearing\n * //=bearing\n */\nfunction bearing(start, end, final) {\n    if (final === true) return calculateFinalBearing(start, end);\n\n    var degrees2radians = Math.PI / 180;\n    var radians2degrees = 180 / Math.PI;\n    var coordinates1 = getCoord(start);\n    var coordinates2 = getCoord(end);\n\n    var lon1 = degrees2radians * coordinates1[0];\n    var lon2 = degrees2radians * coordinates2[0];\n    var lat1 = degrees2radians * coordinates1[1];\n    var lat2 = degrees2radians * coordinates2[1];\n    var a = Math.sin(lon2 - lon1) * Math.cos(lat2);\n    var b = Math.cos(lat1) * Math.sin(lat2) -\n        Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);\n\n    var bear = radians2degrees * Math.atan2(a, b);\n\n    return bear;\n}\n\n/**\n * Calculates Final Bearing\n * @private\n * @param {Feature<Point>} start starting Point\n * @param {Feature<Point>} end ending Point\n * @returns {number} bearing\n */\nfunction calculateFinalBearing(start, end) {\n    // Swap start & end\n    var bear = bearing(end, start);\n    bear = (bear + 180) % 360;\n    return bear;\n}\n\nmodule.exports = bearing;\n","import turfDestination from '@turf/destination'\nimport turfCentroid from '@turf/centroid'\nimport turfBearing from '@turf/bearing'\nimport turfDistance from '@turf/distance'\n\nexport function fromFeature (feature, options) {\n  options = options || {}\n  feature = checkFeatures(feature, options)\n  return processFeature(feature, options)\n}\n\nvar units = 'meters'\n\nfunction tanDeg (deg) {\n  var rad = deg * Math.PI / 180\n  return Math.tan(rad)\n}\n\nfunction cosDeg (deg) {\n  var rad = deg * Math.PI / 180\n  return Math.cos(rad)\n}\n\nfunction getNested (feature, options) {\n  var properties = feature.properties || {}\n  if (options.nested) {\n    if (properties[options.nested]) {\n      properties = properties[options.nested]\n    } else {\n      properties = {}\n    }\n  }\n  return properties\n}\n\nfunction checkFeatures (feature, options) {\n  var properties = getNested(feature, options)\n  var angle = properties.angle || options.angle\n\n  var geometryType = feature.geometry.type\n\n  if (geometryType === 'GeometryCollection') {\n    if (feature.geometry.geometries.length === 3 &&\n        feature.geometry.geometries[0].type === 'Point' &&\n        feature.geometry.geometries[1].type === 'Point' &&\n        feature.geometry.geometries[2].type === 'Point') {\n      return feature\n    }\n  }\n\n  if (angle === undefined) {\n    throw new Error('feature must include angle property, or global angle option must be set')\n  }\n\n  if (geometryType === 'LineString') {\n    if (feature.geometry.coordinates.length === 2) {\n      return feature\n    } else {\n      throw new Error('only accepts only accepts LineStrings with two points')\n    }\n  } else if (geometryType === 'GeometryCollection') {\n    if (feature.geometry.geometries.length === 2 &&\n        feature.geometry.geometries[0].type === 'Point' &&\n        feature.geometry.geometries[1].type === 'Point') {\n      return feature\n    } else {\n      throw new Error('only accepts GeometryCollections containing two Points')\n    }\n  } else if (geometryType === 'Point') {\n    if (properties.bearing !== undefined && properties.distance !== undefined) {\n      return feature\n    } else {\n      throw new Error('only accepts single Points with distance and bearing properties')\n    }\n  } else {\n    throw new Error('only accepts LineStrings with two points, GeometryCollections \\n' +\n      'containing two Points, or single Points with distance and bearing properties\\n' +\n      ' - without the angle property set, GeometryCollections with three Points are accepted')\n  }\n}\n\nfunction processFeature (feature, options) {\n  var geometryType = feature.geometry.type\n  if (geometryType === 'Point') {\n    return processPoint(feature, options)\n  } else if (geometryType === 'LineString') {\n    return processLineString(feature, options)\n  } else if (geometryType === 'GeometryCollection') {\n    return processGeometryCollection(feature, options)\n  }\n}\n\nfunction processPoint (feature, options) {\n  var properties = getNested(feature, options)\n\n  var distance = properties.distance\n  var angle = properties.angle || options.angle\n\n  var centroid = turfDestination(feature, distance, properties.bearing, units)\n\n  var distCentroid = tanDeg(angle / 2) * distance\n\n  var points = [\n    turfDestination(centroid, distCentroid, properties.bearing + 90, units),\n    turfDestination(centroid, -distCentroid, properties.bearing + 90, units)\n  ]\n\n  return {\n    type: 'Feature',\n    properties: feature.properties,\n    geometry: {\n      type: 'GeometryCollection',\n      geometries: [\n        feature.geometry,\n        {\n          type: 'LineString',\n          coordinates: [\n            points[0].geometry.coordinates,\n            points[1].geometry.coordinates\n          ]\n        }\n      ]\n    }\n  }\n}\n\nfunction processLineString (feature, options) {\n  var properties = getNested(feature, options)\n  var angle = properties.angle || options.angle\n\n  var centroid = turfCentroid(feature)\n\n  var points = feature.geometry.coordinates.map(function (coordinate) {\n    return {\n      type: 'Feature',\n      geometry: {\n        type: 'Point',\n        coordinates: coordinate\n      }\n    }\n  })\n\n  var distCentroid = turfDistance(points[0], centroid, units)\n  var bearing = turfBearing(points[0], points[1])\n\n  var distCamera = distCentroid / tanDeg(angle / 2)\n  var camera = turfDestination(centroid, distCamera, bearing + 90, units)\n\n  return {\n    type: 'Feature',\n    properties: feature.properties,\n    geometry: {\n      type: 'GeometryCollection',\n      geometries: [\n        camera.geometry,\n        feature.geometry\n      ]\n    }\n  }\n}\n\nfunction processGeometryCollection (feature, options) {\n  var points = feature.geometry.geometries\n\n  var camera = points[0]\n  var target = points[1]\n  var targetBearing = turfBearing(camera, target)\n\n  var angle\n\n  if (points.length === 2) {\n    var properties = getNested(feature, options)\n    angle = properties.angle || options.angle\n  } else {\n    var angleBearing = turfBearing(camera, points[2])\n    var bearingDiff = (angleBearing - targetBearing + 360) % 180\n\n    if (bearingDiff < 90) {\n      angle = bearingDiff * 2\n    } else {\n      angle = (180 - bearingDiff) * 2\n    }\n  }\n\n  var distance = turfDistance(camera, target, units)\n  var distFieldOfViewCorner = distance / cosDeg(angle / 2)\n\n  var fieldOfViewPoint1 = turfDestination(camera, distFieldOfViewCorner, targetBearing - angle / 2, units)\n  var fieldOfViewPoint2 = turfDestination(camera, distFieldOfViewCorner, targetBearing + angle / 2, units)\n\n  return {\n    type: 'Feature',\n    properties: Object.assign({}, feature.properties, {\n      angle: angle,\n      bearing: targetBearing,\n      distance: distance\n    }),\n    geometry: {\n      type: 'GeometryCollection',\n      geometries: [\n        camera,\n        {\n          type: 'LineString',\n          coordinates: [\n            fieldOfViewPoint1.geometry.coordinates,\n            fieldOfViewPoint2.geometry.coordinates\n          ]\n        }\n      ]\n    }\n  }\n}\n","import L from 'Leaflet'\n\nexport default L.Evented.extend({\n  options: {\n    controlCrosshairImg: '../images/crosshair-icon.svg',\n    crosshairHTML: '<img alt=\"Center of the map; crosshair location\" title=\"Crosshair\" src=\"' + options.controlCrosshairImg + '\" width=\"100px\" />'\n  },\n\n  initialize: function (options) {\n    L.setOptions(this, options)\n  },\n\n  addTo: function (map) {\n    this._map = map\n    var container = map.getContainer()\n    this._element = L.DomUtil.create('div', 'leaflet-geotag-photo-crosshair', container)\n    this._element.innerHTML = this.options.crosshairHTML\n\n    this._boundOnInput = this._onInput.bind(this)\n    this._boundOnChange = this._onChange.bind(this)\n\n    this._map.on('move', this._boundOnInput)\n    this._map.on('moveend', this._boundOnChange)\n\n    return this\n  },\n\n  removeFrom: function (map) {\n    if (this._map && this._boundOnInput && this._boundOnChange) {\n      this._map.off('move', this._boundOnInput)\n      this._map.off('moveend', this._boundOnChange)\n    }\n\n    if (this._element) {\n      L.DomUtil.remove(this._element)\n    }\n\n    return this\n  },\n\n  _onInput: function () {\n    this.fire('input')\n  },\n\n  _onChange: function () {\n    this.fire('change')\n  },\n\n  getCrosshairLatLng: function () {\n    return this._map.getCenter()\n  },\n\n  getCrosshairPoint: function () {\n    if (this._map) {\n      var center = this.getCrosshairLatLng()\n      return {\n        type: 'Point',\n        coordinates: [\n          center.lng,\n          center.lat\n        ]\n      }\n    }\n  }\n\n})\n","//http://en.wikipedia.org/wiki/Haversine_formula\n//http://www.movable-type.co.uk/scripts/latlong.html\nvar getCoord = require('@turf/invariant').getCoord;\nvar helpers = require('@turf/helpers');\nvar point = helpers.point;\nvar distanceToRadians = helpers.distanceToRadians;\n\n/**\n * Takes a {@link Point} and calculates the location of a destination point given a distance in degrees, radians, miles, or kilometers; and bearing in degrees. This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.\n *\n * @name destination\n * @param {Feature<Point>} from starting point\n * @param {number} distance distance from the starting point\n * @param {number} bearing ranging from -180 to 180\n * @param {string} [units=kilometers] miles, kilometers, degrees, or radians\n * @returns {Feature<Point>} destination point\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {\n *     \"marker-color\": \"#0f0\"\n *   },\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [-75.343, 39.984]\n *   }\n * };\n * var distance = 50;\n * var bearing = 90;\n * var units = 'miles';\n *\n * var destination = turf.destination(point, distance, bearing, units);\n * destination.properties['marker-color'] = '#f00';\n *\n * var result = {\n *   \"type\": \"FeatureCollection\",\n *   \"features\": [point, destination]\n * };\n *\n * //=result\n */\nmodule.exports = function (from, distance, bearing, units) {\n    var degrees2radians = Math.PI / 180;\n    var radians2degrees = 180 / Math.PI;\n    var coordinates1 = getCoord(from);\n    var longitude1 = degrees2radians * coordinates1[0];\n    var latitude1 = degrees2radians * coordinates1[1];\n    var bearing_rad = degrees2radians * bearing;\n\n    var radians = distanceToRadians(distance, units);\n\n    var latitude2 = Math.asin(Math.sin(latitude1) * Math.cos(radians) +\n        Math.cos(latitude1) * Math.sin(radians) * Math.cos(bearing_rad));\n    var longitude2 = longitude1 + Math.atan2(Math.sin(bearing_rad) *\n        Math.sin(radians) * Math.cos(latitude1),\n        Math.cos(radians) - Math.sin(latitude1) * Math.sin(latitude2));\n\n    return point([radians2degrees * longitude2, radians2degrees * latitude2]);\n};\n","var each = require('@turf/meta').coordEach;\nvar point = require('@turf/helpers').point;\n\n/**\n * Takes one or more features and calculates the centroid using\n * the mean of all vertices.\n * This lessens the effect of small islands and artifacts when calculating\n * the centroid of a set of polygons.\n *\n * @name centroid\n * @param {(Feature|FeatureCollection)} features input features\n * @returns {Feature<Point>} the centroid of the input features\n * @example\n * var poly = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Polygon\",\n *     \"coordinates\": [[\n *       [105.818939,21.004714],\n *       [105.818939,21.061754],\n *       [105.890007,21.061754],\n *       [105.890007,21.004714],\n *       [105.818939,21.004714]\n *     ]]\n *   }\n * };\n *\n * var centroidPt = turf.centroid(poly);\n *\n * var result = {\n *   \"type\": \"FeatureCollection\",\n *   \"features\": [poly, centroidPt]\n * };\n *\n * //=result\n */\nmodule.exports = function (features) {\n    var xSum = 0, ySum = 0, len = 0;\n    each(features, function (coord) {\n        xSum += coord[0];\n        ySum += coord[1];\n        len++;\n    }, true);\n    return point([xSum / len, ySum / len]);\n};\n","var getCoord = require('@turf/invariant').getCoord;\nvar radiansToDistance = require('@turf/helpers').radiansToDistance;\n//http://en.wikipedia.org/wiki/Haversine_formula\n//http://www.movable-type.co.uk/scripts/latlong.html\n\n/**\n * Calculates the distance between two {@link Point|points} in degrees, radians,\n * miles, or kilometers. This uses the\n * [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula)\n * to account for global curvature.\n *\n * @name distance\n * @param {Feature<Point>} from origin point\n * @param {Feature<Point>} to destination point\n * @param {string} [units=kilometers] can be degrees, radians, miles, or kilometers\n * @returns {number} distance between the two points\n * @example\n * var from = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [-75.343, 39.984]\n *   }\n * };\n * var to = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [-75.534, 39.123]\n *   }\n * };\n * var units = \"miles\";\n *\n * var points = {\n *   \"type\": \"FeatureCollection\",\n *   \"features\": [from, to]\n * };\n *\n * //=points\n *\n * var distance = turf.distance(from, to, units);\n *\n * //=distance\n */\nmodule.exports = function (from, to, units) {\n    var degrees2radians = Math.PI / 180;\n    var coordinates1 = getCoord(from);\n    var coordinates2 = getCoord(to);\n    var dLat = degrees2radians * (coordinates2[1] - coordinates1[1]);\n    var dLon = degrees2radians * (coordinates2[0] - coordinates1[0]);\n    var lat1 = degrees2radians * coordinates1[1];\n    var lat2 = degrees2radians * coordinates2[1];\n\n    var a = Math.pow(Math.sin(dLat / 2), 2) +\n          Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);\n\n    return radiansToDistance(2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)), units);\n};\n","import L from 'Leaflet'\n\nexport default L.Control.extend({\n  options: {\n    position: 'topleft'\n  },\n\n  initialize: function (geotagPhotoCamera, options) {\n    this._geotagPhotoCamera = geotagPhotoCamera\n    L.setOptions(this, options)\n  },\n\n  onAdd: function (map) {\n    this._map = map\n\n    var controlName = 'leaflet-control-geotag-photo-'\n    var container = L.DomUtil.create('div', controlName + ' leaflet-bar')\n\n    var cameraImg = '<img role=\"none\" src=\"' + this.options.cameraImg + '\" />'\n    var crosshairImg = '<img role=\"none\" src=\"' + this.options.crosshairImg + '\" />'\n\n    this._cameraButton = this._createButton(cameraImg, 'Move camera back to map (C)',\n      controlName + 'camera', container, this._centerCamera)\n\n    this._crosshairButton = this._createButton(crosshairImg, 'Move map back to camera (M)',\n      controlName + 'crosshair', container, this._centerMap)\n\n    this._boundMapKeyPress = this._mapKeyPress.bind(this)\n    this._map.on('keypress', this._boundMapKeyPress)\n\n    return container\n  },\n\n  _createButton: function (html, title, className, container, fn) {\n    var link = L.DomUtil.create('a', className, container)\n    link.innerHTML = html\n    link.href = '#'\n    link.title = title\n\n    /*\n     * Will force screen readers like VoiceOver to read this as \"Zoom in - button\"\n     */\n    link.setAttribute('role', 'button')\n    link.setAttribute('aria-label', title)\n\n    L.DomEvent\n      .on(link, 'mousedown dblclick', L.DomEvent.stopPropagation)\n      .on(link, 'click', L.DomEvent.stop)\n      .on(link, 'click', fn, this)\n      .on(link, 'click', this._refocusOnMap, this)\n\n    return link\n  },\n\n  onRemove: function (map) {\n    L.DomUtil.remove(this._element)\n    map.off('keypress', this._boundMapKeyPress)\n  },\n\n  _mapKeyPress: function (evt) {\n    if (evt.originalEvent.charCode === 99) {\n      // C key\n      this._centerCamera()\n    } else if (evt.originalEvent.charCode === 109) {\n      // M key\n      this._centerMap()\n    }\n  },\n\n  _centerCamera: function () {\n    if (this._map && this._geotagPhotoCamera) {\n      this._geotagPhotoCamera.centerBounds(this._map.getBounds())\n    }\n  },\n\n  _centerMap: function () {\n    if (this._map && this._geotagPhotoCamera) {\n      this._map.fitBounds(this._geotagPhotoCamera.getBounds())\n    }\n  }\n\n})\n","import L from 'Leaflet'\nimport { fromFeature } from 'field-of-view'\n\nimport GeotagPhotoCameraControl from './Leaflet.GeotagPhoto.CameraControl'\n\nL.geotagPhotoCameraControl = function (geotagPhotoCamera, options) {\n  return new GeotagPhotoCameraControl(geotagPhotoCamera, options)\n}\n\nexport default L.FeatureGroup.extend({\n\n  options: {\n    // Whether the camera is draggable with mouse/touch or not\n    draggable: true,\n\n    // Whether to show camera control buttons\n    control: true,\n\n    // Whether the angle of the field-of-view can be changed with a draggable marker\n    angleMarker: true,\n\n    minAngle: 5,\n    maxAngle: 120,\n\n    // Control button images\n    controlCameraImg: '../images/camera-icon.svg',\n    controlCrosshairImg: '../images/crosshair-icon.svg',\n\n    cameraIcon: L.icon({\n      iconUrl: '../images/camera.svg',\n      iconSize: [38, 38],\n      iconAnchor: [19, 19]\n    }),\n\n    targetIcon: L.icon({\n      iconUrl: '../images/marker.svg',\n      iconSize: [32, 32],\n      iconAnchor: [16, 16]\n    }),\n\n    angleIcon: L.icon({\n      iconUrl: '../images/marker.svg',\n      iconSize: [32, 32],\n      iconAnchor: [16, 16]\n    }),\n\n    outlineStyle: {\n      color: 'black',\n      opacity: 0.5,\n      weight: 2,\n      dashArray: '5, 7',\n      lineCap: 'round',\n      lineJoin: 'round'\n    },\n\n    fillStyle: {\n      weight: 0,\n      fillOpacity: 0.2,\n      fillColor: '#3388ff'\n    }\n  },\n\n  initialize: function (feature, options) {\n    L.setOptions(this, options)\n\n    this.options.minAngle = Math.max(this.options.minAngle, 1)\n    this.options.maxAngle = Math.min(this.options.maxAngle, 179)\n\n    this._fieldOfView = fromFeature(feature)\n    this._angle = this._fieldOfView.properties.angle\n\n    var layers = this._createLayers()\n    L.LayerGroup.prototype.initialize.call(this, layers)\n\n    this.setDraggable(this.options.draggable)\n  },\n\n  _createLayers: function () {\n    this._cameraIcon = this.options.cameraIcon\n    this._targetIcon = this.options.targetIcon\n    this._angleIcon = this.options.angleIcon\n\n    var pointList = this._getPointList(this._fieldOfView)\n    var cameraLatLng = this._getCameraFromPointList(pointList)\n    var targetLatLng = this._getTargetFromPointList(pointList)\n    var angleLatLng = this._getAngleFromPointList(pointList)\n\n    this._polyline = L.polyline(pointList, this.options.outlineStyle)\n    this._polygon = L.polygon(pointList, Object.assign(this.options.fillStyle, {\n      className: 'field-of-view'\n    }))\n\n    this._control = L.geotagPhotoCameraControl(this, {\n      cameraImg: this.options.controlCameraImg,\n      crosshairImg: this.options.controlCrosshairImg\n    })\n\n    this._cameraMarker = L.marker(cameraLatLng, {\n      icon: this._cameraIcon,\n      draggable: this.options.draggable,\n      zIndexOffset: 600,\n      title: 'Camera',\n      alt: 'Location of the camera'\n    }).on('drag', this._onMarkerDrag, this)\n      .on('dragend', this._onMarkerDragEnd, this)\n\n    this._targetMarker = L.marker(targetLatLng, {\n      icon: this._targetIcon,\n      draggable: this.options.draggable,\n      zIndexOffset: 200,\n      title: 'Target',\n      alt: 'Location of the target'\n    }).on('drag', this._onMarkerDrag, this)\n      .on('dragend', this._onMarkerDragEnd, this)\n\n    this._angleMarker = L.marker(angleLatLng, {\n      icon: this._angleIcon,\n      draggable: this.options.draggable,\n      zIndexOffset: 400,\n      title: 'Angle',\n      alt: 'Field of view angle'\n    }).on('drag', this._onAngleMarkerDrag, this)\n      .on('dragend', this._onMarkerDragEnd, this)\n\n    var boundUpdateMarkerBearings = this._updateMarkerBearings.bind(this)\n    var markerSetPos = function (pos) {\n      var protoMarkerSetPos = L.Marker.prototype._setPos\n      protoMarkerSetPos.call(this, pos)\n      boundUpdateMarkerBearings()\n    }\n\n    this._cameraMarker._setPos = this._targetMarker._setPos = markerSetPos\n\n    return [\n      this._polygon,\n      this._polyline,\n      this._targetMarker,\n      this._angleMarker,\n      this._cameraMarker\n    ]\n  },\n\n  addTo: function (map) {\n    this._map = map\n\n    L.FeatureGroup.prototype.addTo.call(this, map)\n\n    if (this.options.control) {\n      this._control.addTo(map)\n    }\n\n    this._boundOnDocumentKeyDown = this._onDocumentKeyDown.bind(this)\n    document.addEventListener('keydown', this._boundOnDocumentKeyDown)\n\n    this.setDraggable(this.options.draggable)\n    this._updateMarkerBearings(this._fieldOfView)\n\n    return this\n  },\n\n  removeFrom: function (map) {\n    this._map = undefined\n\n    L.FeatureGroup.prototype.removeFrom.call(this, map)\n\n    if (this._boundOnDocumentKeyDown) {\n      document.removeEventListener('keydown', this._boundOnDocumentKeyDown)\n    }\n\n    return this\n  },\n\n  _getPointList: function (fieldOfView) {\n    return [\n      [\n        fieldOfView.geometry.geometries[1].coordinates[0][1],\n        fieldOfView.geometry.geometries[1].coordinates[0][0]\n      ],\n      [\n        fieldOfView.geometry.geometries[0].coordinates[1],\n        fieldOfView.geometry.geometries[0].coordinates[0]\n      ],\n      [\n        fieldOfView.geometry.geometries[1].coordinates[1][1],\n        fieldOfView.geometry.geometries[1].coordinates[1][0]\n      ]\n    ]\n  },\n\n  _getCameraFromPointList: function (pointList) {\n    return pointList[1]\n  },\n\n  _getTargetFromPointList: function (pointList) {\n    return [\n      (pointList[0][0] + pointList[2][0]) / 2,\n      (pointList[0][1] + pointList[2][1]) / 2\n    ]\n  },\n\n  _getAngleFromPointList: function (pointList) {\n    return pointList[2]\n  },\n\n  _addRotateTransform: function (element, rotation) {\n    if (!element) {\n      return\n    }\n\n    var transform = element.style[L.DomUtil.TRANSFORM]\n    var rotate = 'rotate(' + rotation + ')'\n\n    element.style.transformOrigin = 'center center'\n\n    if (transform.indexOf('rotate') !== -1) {\n      element.style[L.DomUtil.TRANSFORM] = transform.replace(/rotate\\(.*?\\)/, rotate)\n    } else {\n      element.style[L.DomUtil.TRANSFORM] = transform + ' ' + rotate\n    }\n  },\n\n  _updateMarkerBearings: function (fieldOfView) {\n    fieldOfView = fieldOfView || this._fieldOfView\n\n    var bearing = fieldOfView.properties.bearing\n    var angle = fieldOfView.properties.angle\n    this._addRotateTransform(this._cameraMarker._icon, bearing + 'deg')\n    this._addRotateTransform(this._targetMarker._icon, bearing + 'deg')\n    this._addRotateTransform(this._angleMarker._icon, (bearing + angle / 2) + 'deg')\n  },\n\n  _drawFieldOfView: function (fieldOfView) {\n    fieldOfView = fieldOfView || this._fieldOfView\n\n    var pointList = this._getPointList(fieldOfView)\n    this._polyline.setLatLngs(pointList)\n    this._polygon.setLatLngs(pointList)\n  },\n\n  _updateFieldOfView: function () {\n    var angle = this._angle\n    var cameraLatLng = this._cameraMarker.getLatLng()\n    var targetLatLng = this._targetMarker.getLatLng()\n\n    var cameraTarget = {\n      type: 'Feature',\n      properties: {\n        angle: angle\n      },\n      geometry: {\n        type: 'GeometryCollection',\n        geometries: [\n          this._geoJsonPoint(cameraLatLng),\n          this._geoJsonPoint(targetLatLng)\n        ]\n      }\n    }\n\n    this._fieldOfView = fromFeature(cameraTarget)\n\n    var angleLatLng = this._getAngleFromPointList(this._getPointList(this._fieldOfView))\n    this._angleMarker.setLatLng(angleLatLng)\n\n    this._updateMarkerBearings(this._fieldOfView)\n    this._drawFieldOfView(this._fieldOfView)\n  },\n\n  _onAngleMarkerDrag: function (evt) {\n    var cameraLatLng = this._cameraMarker.getLatLng()\n    var targetLatLng = this._targetMarker.getLatLng()\n    var angleLatLng = this._angleMarker.getLatLng()\n\n    var points = {\n      type: 'Feature',\n      geometry: {\n        type: 'GeometryCollection',\n        geometries: [\n          this._geoJsonPoint(cameraLatLng),\n          this._geoJsonPoint(targetLatLng),\n          this._geoJsonPoint(angleLatLng)\n        ]\n      }\n    }\n\n    this._fieldOfView = fromFeature(points)\n    this.setAngle(this._fieldOfView.properties.angle)\n  },\n\n  _onMarkerDrag: function (evt) {\n    this._updateFieldOfView()\n    this.fire('input')\n  },\n\n  _onMarkerDragEnd: function (evt) {\n    this.fire('change')\n  },\n\n  _moveMarker: function (marker, offset) {\n    var point = this._map.latLngToContainerPoint(marker.getLatLng())\n    point = point.add(offset)\n    var latLng = this._map.containerPointToLatLng(point)\n    marker.setLatLng(latLng)\n\n    this._updateFieldOfView()\n    this.fire('change')\n  },\n\n  _onMarkerKeyDown: function (marker, evt) {\n    var moveDelta = 20\n    if (evt.shiftKey) {\n      moveDelta = moveDelta * 4\n    }\n\n    if (evt.keyCode === 37) {\n      // left\n      this._moveMarker(marker, L.point(-moveDelta, 0))\n    } else if (evt.keyCode === 38) {\n      // up\n      this._moveMarker(marker, L.point(0, -moveDelta))\n    } else if (evt.keyCode === 39) {\n      // right\n      this._moveMarker(marker, L.point(moveDelta, 0))\n    } else if (evt.keyCode === 40) {\n      // down\n      this._moveMarker(marker, L.point(0, moveDelta))\n    }\n  },\n\n  _onAngleMarkerKeyDown: function (evt) {\n    var angleDelta = 2.5\n    if (evt.shiftKey) {\n      angleDelta = angleDelta * 4\n    }\n\n    if (evt.keyCode === 37) {\n      // left\n      this.setAngle(this._angle - angleDelta)\n    } else if (evt.keyCode === 39) {\n      // right\n      this.setAngle(this._angle + angleDelta)\n    }\n  },\n\n  _onDocumentKeyDown: function (evt) {\n    if (document.activeElement === this._cameraMarker._icon) {\n      this._onMarkerKeyDown(this._cameraMarker, evt)\n    } else if (document.activeElement === this._targetMarker._icon) {\n      this._onMarkerKeyDown(this._targetMarker, evt)\n    } else if (document.activeElement === this._angleMarker._icon) {\n      this._onAngleMarkerKeyDown(evt)\n    }\n  },\n\n  _setMarkerVisible: function (marker, visible) {\n    marker._icon.style.display = visible ? 'inherit' : 'none'\n  },\n\n  _geoJsonPoint: function (latLng) {\n    return {\n      type: 'Point',\n      coordinates: [latLng.lng, latLng.lat]\n    }\n  },\n\n  getFieldOfView: function () {\n    return this._fieldOfView\n  },\n\n  getCameraLatLng: function () {\n    return this._cameraMarker.getLatLng()\n  },\n\n  getTargetLatLng: function () {\n    return this._targetMarker.getLatLng()\n  },\n\n  getCameraPoint: function () {\n    return this._geoJsonPoint(this.getCameraLatLng())\n  },\n\n  getTargetPoint: function () {\n    return this._geoJsonPoint(this.getTargetLatLng())\n  },\n\n  getCenter: function () {\n    if (!this._map) {\n      return\n    }\n\n    return L.latLngBounds([\n      this.getCameraLatLng(),\n      this.getTargetLatLng()\n    ]).getCenter()\n  },\n\n  centerBounds: function (bounds) {\n    var cameraBounds = this.getBounds()\n\n    if (!bounds.contains(cameraBounds)) {\n      var center = this.getCenter()\n      var cameraLatLng = this.getCameraLatLng()\n      var targetLatLng = this.getTargetLatLng()\n\n      var boundsCenter = bounds.getCenter()\n\n      var newCameraLatLng = [\n        boundsCenter.lat - (center.lat - cameraLatLng.lat),\n        boundsCenter.lng - (center.lng - cameraLatLng.lng)\n      ]\n\n      var newTargetLatLng = [\n        boundsCenter.lat - (center.lat - targetLatLng.lat),\n        boundsCenter.lng - (center.lng - targetLatLng.lng)\n      ]\n\n      this.setCameraAndTargetLatLng(newCameraLatLng, newTargetLatLng)\n    }\n  },\n\n  setCameraLatLng: function (latLng) {\n    if (!this._map) {\n      return\n    }\n\n    this._cameraMarker.setLatLng(latLng)\n    this._updateFieldOfView()\n    this.fire('change')\n  },\n\n  setTargetLatLng: function (latLng) {\n    if (!this._map) {\n      return\n    }\n\n    this._targetMarker.setLatLng(latLng)\n    this._updateFieldOfView()\n    this.fire('change')\n  },\n\n  setCameraAndTargetLatLng: function (cameraLatLng, targetLatLng) {\n    if (!this._map) {\n      return\n    }\n\n    this._cameraMarker.setLatLng(cameraLatLng)\n    this._targetMarker.setLatLng(targetLatLng)\n    this._updateFieldOfView()\n    this.fire('change')\n  },\n\n  getBounds: function () {\n    if (!this._fieldOfView) {\n      return\n    }\n\n    var pointList = this._getPointList(this._fieldOfView)\n    return L.latLngBounds(pointList)\n  },\n\n  setAngle: function (angle) {\n    this._angle = Math.max(Math.min(angle, this.options.maxAngle), this.options.minAngle)\n    this._updateFieldOfView()\n    this.fire('input')\n  },\n\n  setDraggable: function (draggable) {\n    if (!this._map) {\n      return\n    }\n\n    if (draggable) {\n      this._cameraMarker.dragging.enable()\n      this._targetMarker.dragging.enable()\n      this._angleMarker.dragging.enable()\n    } else {\n      this._cameraMarker.dragging.disable()\n      this._targetMarker.dragging.disable()\n      this._angleMarker.dragging.disable()\n    }\n\n    this._setMarkerVisible(this._targetMarker, draggable)\n    this._setMarkerVisible(this._angleMarker, draggable && this.options.angleMarker)\n  }\n\n})\n","'use strict'\n\nimport L from 'Leaflet'\nimport GeotagPhotoCrosshair from './src/Leaflet.GeotagPhoto.Crosshair'\nimport GeotagPhotoCamera from './src/Leaflet.GeotagPhoto.Camera'\n\n// Object.assign polyfill, for IE<=11. From:\n//   https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#Polyfill\n// TODO: I'm sure Babel can add this polyfill, too.\nif (typeof Object.assign !== 'function') {\n  Object.assign = function (target, varArgs) {\n    if (target == null) {\n      throw new TypeError('Cannot convert undefined or null to object')\n    }\n\n    var to = Object(target)\n\n    for (var index = 1; index < arguments.length; index++) {\n      var nextSource = arguments[index]\n\n      if (nextSource != null) {\n        for (var nextKey in nextSource) {\n          if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n            to[nextKey] = nextSource[nextKey]\n          }\n        }\n      }\n    }\n    return to\n  }\n}\n\nL.geotagPhoto = {\n  crosshair: function (options) {\n    return new GeotagPhotoCrosshair(options)\n  },\n  camera: function (feature, options) {\n    return new GeotagPhotoCamera(feature, options)\n  }\n}\n\nL.GeotagPhoto = {\n  Crosshair: GeotagPhotoCrosshair,\n  Camera: GeotagPhotoCamera\n}\n"],"names":["getCoord","obj","Error","coordinates","getCoords","length","geometry","containsNumber","geojsonType","value","type","name","featureOf","feature","collectionOf","featureCollection","i","features","properties","coordEach","layer","callback","excludeWrapCoord","j","k","g","l","stopG","coords","geometryMaybeCollection","isGeometryCollection","wrapShrink","currentIndex","isFeatureCollection","isFeature","stop","geometries","coordReduce","initialValue","previousValue","currentCoords","undefined","propEach","propReduce","currentProperties","featureEach","featureReduce","currentFeature","coordAll","coord","push","geomEach","geomReduce","currentGeometry","bearing","start","end","final","calculateFinalBearing","degrees2radians","Math","PI","radians2degrees","coordinates1","coordinates2","lon1","lon2","lat1","lat2","a","sin","cos","b","atan2","bear","fromFeature","options","checkFeatures","processFeature","tanDeg","deg","rad","tan","cosDeg","getNested","nested","angle","geometryType","distance","processPoint","processLineString","processGeometryCollection","centroid","turfDestination","units","distCentroid","points","turfCentroid","map","coordinate","turfDistance","turfBearing","distCamera","camera","target","targetBearing","angleBearing","bearingDiff","distFieldOfViewCorner","fieldOfViewPoint1","fieldOfViewPoint2","Object","assign","L","Evented","extend","controlCrosshairImg","setOptions","this","_map","container","getContainer","_element","DomUtil","create","innerHTML","crosshairHTML","_boundOnInput","_onInput","bind","_boundOnChange","_onChange","on","off","remove","fire","getCenter","center","getCrosshairLatLng","lng","lat","ring","factors","miles","nauticalmiles","degrees","radians","inches","yards","meters","metres","kilometers","kilometres","feet","factor","require$$1","helpers","require$$0","point","distanceToRadians","from","longitude1","latitude1","bearing_rad","latitude2","asin","longitude2","each","xSum","ySum","len","radiansToDistance","to","dLat","dLon","pow","sqrt","Control","geotagPhotoCamera","_geotagPhotoCamera","controlName","cameraImg","crosshairImg","_cameraButton","_createButton","_centerCamera","_crosshairButton","_centerMap","_boundMapKeyPress","_mapKeyPress","html","title","className","fn","link","href","setAttribute","DomEvent","stopPropagation","_refocusOnMap","evt","originalEvent","charCode","centerBounds","getBounds","fitBounds","geotagPhotoCameraControl","GeotagPhotoCameraControl","FeatureGroup","icon","minAngle","max","maxAngle","min","_fieldOfView","_angle","layers","_createLayers","LayerGroup","prototype","initialize","call","setDraggable","draggable","_cameraIcon","cameraIcon","_targetIcon","targetIcon","_angleIcon","angleIcon","pointList","_getPointList","cameraLatLng","_getCameraFromPointList","targetLatLng","_getTargetFromPointList","angleLatLng","_getAngleFromPointList","_polyline","polyline","outlineStyle","_polygon","polygon","fillStyle","_control","controlCameraImg","_cameraMarker","marker","_onMarkerDrag","_onMarkerDragEnd","_targetMarker","_angleMarker","_onAngleMarkerDrag","boundUpdateMarkerBearings","_updateMarkerBearings","markerSetPos","pos","Marker","_setPos","addTo","control","_boundOnDocumentKeyDown","_onDocumentKeyDown","addEventListener","removeFrom","removeEventListener","fieldOfView","element","rotation","transform","style","TRANSFORM","rotate","transformOrigin","indexOf","replace","_addRotateTransform","_icon","setLatLngs","getLatLng","cameraTarget","_geoJsonPoint","setLatLng","_drawFieldOfView","setAngle","_updateFieldOfView","offset","latLngToContainerPoint","add","latLng","containerPointToLatLng","moveDelta","shiftKey","keyCode","_moveMarker","angleDelta","document","activeElement","_onMarkerKeyDown","_onAngleMarkerKeyDown","visible","display","getCameraLatLng","getTargetLatLng","latLngBounds","bounds","cameraBounds","contains","boundsCenter","newCameraLatLng","newTargetLatLng","setCameraAndTargetLatLng","dragging","enable","disable","_setMarkerVisible","angleMarker","varArgs","TypeError","index","arguments","nextSource","nextKey","hasOwnProperty","geotagPhoto","GeotagPhotoCrosshair","GeotagPhotoCamera","GeotagPhoto"],"mappings":"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"}